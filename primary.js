
/// WELCOME!

/// VARIABLE DECLARATIONS
// Milliseconds between intervals
let refreshRate = 50;
    
// INTERACTABLE DOM Nodes
// within searchDiv (y-based arrangement)
const openFiltersBTN = q('#openFilters');
const brandFilterSCT = q('#brandFilter');
const brandClearBTN = q('#brandClear');
const typeFilterSCT = q('#typeFilter');
const typeClearBTN = q('#typeClear');
const categoryFilterSCT = q('#categoryFilter');
const categoryClearBTN = q('#categoryClear');
const filterMinTXT = q('#filterMin');
const filterMaxTXT = q('#filterMax');
const allAnyBTN = q('#allAny');
const openSortsBTN = q('#openSorts');
const applyConstraintsBTN = q('#applyConstraints');

// within userDiv
const openUserBTN = q('#openUser');
const logInFRM = q('#logInForm');
const logInBTN = q('#logIn');
const registerBTN = q('#register');
const showFavoritesBTN = q('#showFavorites');
const logOutBTN = q('#logOut');

// within metricsDiv
const minBTN = q('#minButton');
const maxBTN = q('#maxButton');


/// DIVS
const topBarDIV = q('#topBarDiv');
const userDIV = q('#userDiv');
const logInDIV = q('#logInDiv');
const userOptionsDIV = q('#userOptionsDiv');
const filterDIV = q('#filterDiv');
const tagsDIV = q('#tagsDiv');
const sortDIV = q('#sortDiv');
const displayDIV = q('#displayDiv');
const highlightDIV = q('#highlight');

 /// TEXT AND MESSAGES
const greeting = q('#greeting');
const loader = q('#loader');
const selectionAvg = q('#selectionAvg');
const selectionMin = q('#selectionMin');
const selectionMax = q('#selectionMax');

/// Variables used in calculation and functionalities
let user = null;
let favoriteProducts = {};
let allProducts = [];
let selectionMetrics = {};
const exchangeRates = {
    '$': 1,
    '£': 1.21,
    '€': 1.06,
    [null]: 1
}
let constrainedProducts = [];
let checkedTags = [];

// For testing CSS updates without fetching to the API
const testingCSS = false;
const demoProd = {
    brand: 'Enigma',
    image_link: '//s3.amazonaws.com/donovanbailey/products/api_featured_images/000/000/896/original/open-uri20171224-4-133ccrb?1514082674',
    description: 'Finally, a lip gloss that will never fade. Go ahead, wear it to bed, we love a challenge.<BR>Shine above all the rest with permagloss, by Enigma.',
    product_type: 'lip_gloss',
    tag_list: ['vegan free','glossless','no pig'],
    website_link: 'https://google.com',
    price: '60.85',
    price_sign: null,
    name: 'Permagloss by Enigma',
    category: 'lip_gloss',
    product_colors: [{
        hex_value: '#abcdef',
        colour_name: 'alphabeta'
    }, {
        hex_value: '#00000f',
        colour_name: 'midnight'
    }, {
        hex_value: '#0f0f0f',
        colour_name: 'groy'
    }, {
        hex_value: '#13fa00',
        colour_name: 'elation'
    }, {
        hex_value: '#f46601',
        colour_name: 'fruitful'
    }, {
        hex_value: '#e11fee',
        colour_name: 'elite'
    }, {
        hex_value: '#777765',
        colour_name: 'numeric'
    }, {
        hex_value: '#fa1e5f',
        colour_name: 'limestone'
    }, {
        hex_value: '#BF2C7E',
        colour_name:'heart on pencil'
    }]
}

const init = () => {

    if(!testingCSS) {
    // GET ARRAY OF ALL PRODUCT OBJECTS FROM API
    fetch('https://makeup-api.herokuapp.com/api/v1/products.json')
    .then(res => res.json())
    .then(json => {
        // assign array of objects to allProducts
        allProducts = json;

        // Udpate each object with data about its index in allProducts (so that it
        // can be referenced even when part of a different array)
        // and its parsed price property (so that it doesn't need to be found
        // at every access)
        for(let i = 0; i < allProducts.length; ++i) {
            allProducts[i].index = i;
            allProducts[i].parsedPrice =
            // Check if the price key's value is null or zero
            ((allProducts[i].price === null)) || (parseFloat(allProducts[i].price) === 0) ?
            // if so, parsedPrice will be null
            null :
            // Otherwise, the parsedPrice property will be set to the parsed value multiplied
            // by the value in exchangeRates stored at the product's .price_sign property
            // so that any comparisons functions will have access to the true value
            parseFloat(allProducts[i].price) * exchangeRates[allProducts[i].price_sign];
            }
        
        // Generate a filtration object for each key that is going to be filterable
        const brand = getFilterObject(allProducts,'brand',filterFormatter,true);
        const type = getFilterObject(allProducts,'product_type',filterFormatter,true);
        const category = getFilterObject(allProducts,'category',filterFormatter,true);
        const tags = getFilterObject(allProducts,'tag_list',filterFormatter,true);


        // DRY UP
        // Fill dropdown menus with the objects generated by getFilterObject()
        populateDropdown(brandFilterSCT,brand.valuesFormatted);

        populateDropdown(typeFilterSCT,type.valuesFormatted);

        populateDropdown(categoryFilterSCT,category.valuesFormatted); 

        // Generate checkboxes based on the generated tags filtration object
        // (This code could be abstracted, but it is only used once in the program)
        for(const tag in tags.valuesFormatted) {
            // Create checkbox element
            const box = buildElement('input',false,[],tag);
            box.type = 'checkbox';
            box.name = 'tags';
            // Set .value to the index of the current tag so that we can reference
            // the value to find the index of the associated string to filter by
            box.value = tag;

            // Build label
            const label = buildElement('label',tags.valuesFormatted[tag]);
            label.setAttribute('for',tag);
            
            // Append elements
            tagsDIV.appendChild(box);
            tagsDIV.appendChild(label);
            tagsDIV.appendChild(buildElement('br'));
        }

        // Initially fill the display with a couple products for visual appeal
        fillDisplay(allProducts.slice(0,12));

        /// CREATE AND EMBED FILTER FUNCTION IN applyConstraints
        ael('click',e => {
            // Make a copy of allProducts for filtration
            constrainedProducts = [...allProducts];
            // If an option other than the default has been selected,
            if (brandFilterSCT.value !== "brand") {
                // filter the copied array by whether or not the product's brand equals the brand string
                // associated with the value attribute of the select element
                constrainedProducts = constrainedProducts.filter(cv => cv.brand === brand.valuesRaw[brandFilterSCT.value]);
            }
            // Do the same for type and category
            if (typeFilterSCT.value !== "type") {
                constrainedProducts = constrainedProducts.filter(cv => cv.product_type === type.valuesRaw[typeFilterSCT.value]);
            }
            if (categoryFilterSCT.value !== "category") {
                constrainedProducts = constrainedProducts.filter(cv => cv.category === category.valuesRaw[categoryFilterSCT.value]);
            }

            /// Filter by min/max price
            // Parse number from the inputted string
            const filterMinValue = parseFloat(filterMinTXT.value);
            // If the parsed value is a number
            if (!isNaN(filterMinValue)) {
                // Filter by whether or not the product's parsedPrice is a number greater than the parsed minumum
                constrainedProducts = constrainedProducts.filter(cv => {
                    if (cv.parsedPrice === null) return false;
                    if (cv.parsedPrice >= filterMinValue) return true;
                    return false;
                });
            };

            // Do the same for maximum
            const filterMaxValue = parseFloat(filterMaxTXT.value);
            if (!isNaN(filterMaxValue)) {
                constrainedProducts = constrainedProducts.filter(cv => {
                    if (cv.parsedPrice === null) return false;
                    if (cv.parsedPrice <= filterMaxValue) return true;
                    return false;
                });
            };

            /// Filter by whether or not tags are present
            // Generate list of all tags checked
            checkedTags = [...tagsDIV.children]
            .filter(cv => cv.checked === true)
            .map(cv => cv.value);


            // Determine if products should be filtered by whether they have ALL or ANY of the checked tags
            // If ALL,
            if (allAnyBTN.textContent === "all") {
                // For every tag in checkedTags, filter products by tag with a similar method as previous,
                // except check to see if tags_list .includes() the associated tag
                // (because tags_list is an array, unlike brand/product_type/category which are strings)
                for(const tag of checkedTags) {
                    constrainedProducts = constrainedProducts.filter(cv => cv.tag_list.includes(tags.valuesRaw[tag]));
                };
                // Otherwise, (if ANY) while considering a product, iterate thru all tags and check if the
                // product's tags_list .includes() it, and return true if one is found at any point
            } else if (checkedTags.length !== 0) {
                constrainedProducts = constrainedProducts.filter(cv => {
                    for(const tag of checkedTags) {
                        if (cv.tag_list.includes(tags.valuesRaw[tag])) return true;
                    };
                    return false;
                });
            };

            /// Sort products based on input
            // Determine which sort to use based on the radio buttons
            const sort = [...q('[type=radio]',true)].find(cv => cv.checked === true);

            // A switch statement runs appropriate code based on which sort was chosen
            if(sort) {
                switch (sort.value) {
                    case 'lowPriceSort':
                        // When a is greater than b (ie the difference will be positive), put a after b
                        constrainedProducts.sort((a,b) => a.parsedPrice - b.parsedPrice);
                        break;
                    case 'highPriceSort':
                        // When a is lesser than b (ie the difference will be negative), put a before b
                        constrainedProducts.sort((a,b) => b.parsedPrice - a.parsedPrice);
                        break;
                    case 'alphaSort':
                        constrainedProducts.sort((a,b) => {
                            // Some strings provided by the API contain their own HTML tags or do not begin
                            // with a capital letter, which throws off sorting based on unicode values,
                            // so all strings are cleared of tags and set to uppercase
                            const aName = clearTags(a.name).toUpperCase();
                            const bName = clearTags(b.name).toUpperCase();
                            // When a is closer the beginning of the alphabet, put a before b
                            if (aName < bName) return -1;
                            // When a is further from the beginning of the alphabet, put a after b
                            if (aName > bName) return 1;
                            if (aName === bName) return 0;
                        });
                        break;
                    case 'revAlphaSort':
                        // Repeat inverted
                        constrainedProducts.sort((a,b) => {
                            const aName = clearTags(a.name).toUpperCase();
                            const bName = clearTags(b.name).toUpperCase();
                            if (aName > bName) return -1;
                            if (aName < bName) return 1;
                            if (aName === bName) return 0;
                        });
                        break;
                    case 'alphaBrandSort':
                        // Repeat with brand names instead
                        constrainedProducts.sort((a,b) => {
                            const aBrand = clearTags(a.brand).toUpperCase();
                            const bBrand = clearTags(b.brand).toUpperCase();
                            if (aBrand < bBrand) return -1;
                            if (aBrand > bBrand) return 1;
                            if (aBrand === bBrand) return 0;
                        });
                        break;
                    case 'revAlphaBrandSort':
                        // Repeat brand names inverted
                        constrainedProducts.sort((a,b) => {
                            const aBrand = clearTags(a.brand).toUpperCase();
                            const bBrand = clearTags(b.brand).toUpperCase();
                            if (aBrand > bBrand) return -1;
                            if (aBrand < bBrand) return 1;
                            if (aBrand === bBrand) return 0;
                        });
                        break;
                    default:
                        // For values of none and any other strange unintended case
                        break;
                }
            }

            // Fill the display with the filtered and sorted list
            fillDisplay(constrainedProducts);
            
        },applyConstraintsBTN);
    });
    } else {

    /// CHECK WITHOUT FETCHING
    for(let i = 0; i < 12; ++i) {
        // Display 12 demonstration cells
        displayDIV.appendChild(buildCell(demoProd,0));
    }
    for (let i = 0; i < 12; ++i) {
        // Push 12 demonstration products into allProducts so some functions may be tested
        allProducts.push(demoProd);
    }
    }

    /// IMPLEMENT SHOW BUTTONS
    implementShowButton(openFiltersBTN,filterDIV,'Show Filters','Close Filters');
    implementShowButton(openSortsBTN,sortDIV,'Show Sorts','Close Sorts');

    /// IMPLEMENT CLEAR SELECTED FILTER BUTTON
    // For each button and select element pair,
    for(const pair of [[brandFilterSCT,brandClearBTN],[typeFilterSCT,typeClearBTN],[categoryFilterSCT,categoryClearBTN]]) {
        // Embed an event into the button that sets the .selectedIndex of the select element
        // to 0
        pair[1].addEventListener('click', e => {
            e.preventDefault();
            pair[0].selectedIndex = 0;
        })
    }

    /// IMPLEMENT SHOW FAVORITES BUTTON
    ael('click',e => {
        e.preventDefault;
        // Fill the display with allProducts filtered by whether or not favoriteProducts's
        // value for the product's id property is true
        fillDisplay(allProducts.filter(cv => favoriteProducts[cv.id]));
    },showFavoritesBTN)

    /// HANDLE INPUTS SUBMITTED WITH THE LOG IN BUTTON
    ael('click',e => {
        e.preventDefault();
        // If logInBTN is clicked while it has the .inactive class, stop the function with a return
        if (logInBTN.classList.contains('inactive')) return;

        // The goal is to check if the string in the password field matches the password resource
        // stored at the user resource of the string in the username field
        // So the code must GET the resource stored at the string in the username field

        // In case errors occur with the request, the code needs access to properties like .ok and .status
        // to properly respond, so initialize variables to externally store the response's .ok and .status
        // properties, since they won't be accessible after the response is converted to JSON
        let status;
        // Call to the mock backend for the resource at the value in the username field
        fetch(`http://localhost:3000/users/${encodeURI(logInFRM.username.value)}`)
        .then(res => {
            // Externally store .status
            status = res.status;
            return res.json();
        })
        .then(json => {
                // if the status type was 404 (requesting a resource that doesn't exist), then the
                // user tried to log in with an account that doesn't exist, so
                s(status,status ===404);
            if (status === 404) {
                // Send the top bar to explain that there is no record of the provided user
                sendTopBar(`Our records show no account registered under ${logInFRM.username.value}`)
            } else
                // But if the response was ok, check if the password value stored in the backend matches
                // the string in the password field
            if ((json.password === logInFRM.password.value)) {
                // if so, log in the user and send a greeting message
                logInUser(json.id);
                sendTopBar(`Welcome back, ${user}!`);
            } else if (json.password !== logInFRM.password.value) {
                // if not, do nothing besides sending and "incorrect password" top bar
                sendTopBar('Incorrect password');
            } else {
                // I don't think there are any other cases, but just in case something unexpected happens,
                // its still a good idea to send the top bar with an "unexpected error" message
                // so the user has some awareness of an issue
                sendTopBar('Unexpected Error, try again');
            }
        })
        .catch(reason => {
            // In cases where the request failed, respond to the situation based on the failure message
                // If the reason.message was 'failed to fetch',
                if (reason.message === 'Failed to fetch') {
                    // then the mock backend was unreachable, so send a 'couldn't access message'
                    sendTopBar('Could not access database');
                } else
                // Otherwise, there was an unexpected error, and no defined procedure, so let
                // the user know, and send the error to the console
                sendTopBar(`Unexpected Error, try again`);
                console.error(reason.message);
        });
    },logInBTN)

    /// REGISTERING NEW ACCOUNT
    ael('click',e => {
        e.preventDefault();
        if (registerBTN.classList.contains('inactive')) return;
        fetch(`http://localhost:3000/users/${encodeURI(logInFRM.username.value)}`)
        .then(res => {
            if (res.status === 404) {
                fetch(`http://localhost:3000/users`,{
                    method: 'POST',
                    headers: {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    body: JSON.stringify({
                        id: logInFRM.username.value,
                        password: logInFRM.password.value
                    })
                })
                .then(res => res.json())
                .then(json => {
                    logInUser(json.id);
                    logInFRM.username.value = '';
                    logInFRM.password.value = '';
                    logInBTN.classList.add('inactive');
                    registerBTN.classList.add('inactive');
                    greeting.textContent = `Hello, ${user}!`
                    sendTopBar(`Registration Success! Welcome to Cosmetrics, ${user}!`);
                });
                } else if (res.ok) sendTopBar(`The account ${logInFRM.username.value} is already taken.`);
            });
    },registerBTN)

    /// DEACTIVATE LOGIN/REGI BUTTONS WHEN FIELDS ARE EMPTY
    ael('keydown',e => {
        setTimeout(() => {
            if ((logInFRM.password.value === '') || (logInFRM.username.value === '')) {
                logInBTN.classList.add('inactive');
                registerBTN.classList.add('inactive');
            } else {
                logInBTN.classList.remove('inactive');
                registerBTN.classList.remove('inactive');
            }
        },1)

    })

    /// LOGGING OUT
    ael('click',e => {
        // Simply run the logOutUser() function when a 'click' event fires on logOutBTN
        e.preventDefault();
        logOutUser();
    },logOutBTN)

    /// CLOSING USER DIV
    ael('click', e => {
        e.preventDefault();
        // Check if the userDIV's display is ''
        userDIV.style.display = userDIV.style.display === '' ?
        // If so, set it to 'block
        'block' :
        // If not, set it to ''
        '';
    },openUserBTN)

    // LOADING DIALOG
    // (Color changing)
    let counter = 0;
    let counterPostCalc = 0;
    const loadingIv = setInterval(() => {
        counterPostCalc = (0.5*Math.sin(++counter/2)+0.5)*255;
        loader.style.color = `rgb(${counterPostCalc},${counterPostCalc},${counterPostCalc})`;
        if (allProducts.length) {
            clearInterval(loadingIv);
            loader.style.display = 'none';
            document.querySelectorAll('.default').forEach(cv => cv.textContent = 'select');
        };
    },refreshRate);

    // SET UP ALL/ANY SWAPPER
    ael('click',e => {
        // Check if allAnyBTN's textContent is 'all'
        allAnyBTN.textContent = allAnyBTN.textContent === 'all' ?
        // if so, set it to any
        'any' :
        // if not, set it to all
        'all';
    },allAnyBTN)

    /// SHOW MIN AND MAX BUTTONS
    ael('click',e => {
        e.preventDefault();
        const childrenArray = [...displayDIV.children];
        if (minBTN.textContent === 'Show') {
            for(const cell of childrenArray) {
                for(const id of selectionMetrics.min.ids) {
                    if (cell.classList[1] === id) {
                        cell.style.display = 'block';
                        break;
                    }
                    cell.style.display = 'none';
                };
            };
            maxBTN.textContent = 'Show';
        } else {
            for (const cell of childrenArray) {
                cell.style.display = 'block';
            };
        };
        minBTN.textContent = minBTN.textContent === 'Show' ? 'Back' : 'Show';
    },minBTN)

    ael('click',e => {
        e.preventDefault();
        const childrenArray = [...displayDIV.children];
        if (maxBTN.textContent === 'Show') {
            for(const cell of childrenArray) {
                for(const id of selectionMetrics.max.ids) {
                    if (cell.classList[1] === id) {
                        cell.style.display = 'block';
                        break;
                    }
                    cell.style.display = 'none';
                };
            };
            minBTN.textContent = 'Show';
        } else {
            for (const cell of childrenArray) {
                cell.style.display = 'block';
            };
        };
        maxBTN.textContent = maxBTN.textContent === 'Show' ? 'Back' : 'Show';
    },maxBTN)

    /// RESIZE GRID DISPLAY
    // Run the function initially so that the window doesn't need to be resized for the
    // calculations to apply
    adjustGrid(displayDIV,window.innerWidth - 532,207);

    ael('resize', e => {
        adjustGrid(displayDIV,window.innerWidth - 532,207);
    },window);
}

document.addEventListener('DOMContentLoaded',init);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCTIONS//BELOW///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function s(...message) {
    for(el of message){
        console.log(el)
    };
};

function ael(event,cb,target = document) {
    return target.addEventListener(event,cb);
}

function q(selector,all = false) {
    if(all) return document.querySelectorAll(selector);
    else return document.querySelector(selector);
}

function buildElement(type,text = undefined,classes = [],id = undefined) {
    const returnElement = document.createElement(type);
    for(el of classes) {
        returnElement.classList.add(el);
    }
    if(id) returnElement.id = id;
    if(text) returnElement.textContent = text;
    return returnElement;
}

function buildCell(product,id) {
    const cell = buildElement('div',null,['prodCell',`${id}`,product.id]);

    const img = buildElement('img',null,['prodImg',`${id}`]);
    img.src = `https://${product.api_featured_image}`;
    cell.appendChild(img);

    const name = buildElement('p',clearTags(product.name),['prodName',`${id}`]);
    cell.appendChild(name);

    const brandText = product.brand ? `by ${capitalizeFirsts(product.brand)}` : 'No Brand Provided';
    const brand = buildElement('a',brandText,['prodBrand',`${id}`]);
    brand.href = product.website_link;
    brand.target = "_blank"
    cell.appendChild(brand);

    /// PRICE
    /// Create div for price
    const priceDiv = buildElement('div','',['priceDiv',`${id}`]);

    /// Prepare variable for price display
    let formattedPrice;
    /// Check to see if a price is listed
    if ((product.price === null) || (product.price === '0.0')) {
        formattedPrice = "Price unlisted, visit the merchant's website";
    } else {
        /// If a price is listed, create currency element and prepare for
        /// price formatting
        formattedPrice = formatPrice(product.parsedPrice);
        const currency = buildElement('p','',['prodCurrency',`${id}`]);

        if (product.price_sign === null) {
            /// Create "No currency provided" popup
            currency.textContent = '$';
            currency.classList.add('none');
    
            const div = buildElement('div',undefined,['popOutDiv',`${id}`])
            currency.appendChild(div)
            const message = buildElement('p',"No currency was provided for this product, visit the merchant's website for more information",['popOutText',`${id}`])
            div.appendChild(message);
    
        } else currency.textContent = '$';
        priceDiv.appendChild(currency);
    }
    
    const price = buildElement('p',`${formattedPrice}`,['prodPrice',`${id}`]);

    priceDiv.appendChild(price);
    cell.appendChild(priceDiv);

    /// COLORS

    if (product.product_colors.length) {
        const colorsDiv = buildElement('div',null,['colorsDiv',`${id}`]);

        let i = 0;

        for(;i < 6; ++i) {
            if (product.product_colors[i]) {
                colorsDiv.appendChild(buildColorBox(product.product_colors[i],id));
            } else break;
        }

        colorsDiv.style.gridTemplateColumns = `repeat(${i}, max-content)`;
        cell.appendChild(colorsDiv);
        if (product.product_colors.length > 6) {
            const more = buildElement('p','More colors');

            const moreColorsDiv = buildElement('div',null,['popOutDiv','moreColorsDiv',`${id}`]);

            const amtOfMoreColors = product.product_colors.length
            
            moreColorsDiv.style.gridTemplateColumns = `repeat(${Math.min(amtOfMoreColors - 6,3)},max-content)`;
            moreColorsDiv.style.left = `${89.25 - (8.5*(Math.min(amtOfMoreColors - 6,3)) + 5*(Math.min(amtOfMoreColors - 6,3) - 1))}px`

            for(let i = 6; i < product.product_colors.length; ++i) {
                moreColorsDiv.appendChild(buildColorBox(product.product_colors[i],id));
            }

            more.appendChild(moreColorsDiv);
            cell.appendChild(more);
        }
    }

    const buttonsDiv = buildElement('div',null,['buttonsDiv',id]);

    /// J2FAVORITE
    const favoriteButton = buildElement('button','Favorite',['favoriteButton'],product.id);
    if (!user) favoriteButton.classList.add('inactive');
    
    ael('click',e => {
        e.preventDefault();
        if (favoriteButton.classList.contains('inactive')) return;
        if (favoriteButton.textContent === 'Favorite') {
	        favoriteProducts[favoriteButton.id] = true;
	        fetch(`http://localhost:3000/users/${encodeURI(user)}`,{
	            method: 'PATCH',
	            headers: {
	                "Content-Type": "application/json",
	                "Accept": "application/json",
	            },
	            body: JSON.stringify({
	                favorites: favoriteProducts
	            })
	        })
	        .then(res => res.json())
	        .then(json => {
	            s(json);
                updateFavorite(cell);
	            sendTopBar('Added to favorites!');
	        });
        }

        if (favoriteButton.textContent === 'Unfavorite') {
            delete favoriteProducts[favoriteButton.id];
            fetch(`http://localhost:3000/users/${encodeURI(user)}`,{
	            method: 'PATCH',
	            headers: {
	                "Content-Type": "application/json",
	                "Accept": "application/json",
	            },
	            body: JSON.stringify({
	                favorites: favoriteProducts
	            })
	        })
	        .then(res => res.json())
	        .then(json => {
	            s(json);
                updateFavorite(cell,false);
	            sendTopBar('Removed from favorites!');
	        });
        }
    },favoriteButton)
    buttonsDiv.appendChild(favoriteButton);

    /// COMPARE j3
    const compareButton = buildElement('button','Compare',['compareButton',id]);

    ael('click',e => {
        highlightDIV.textContent = '';

        highlightDIV.appendChild(img.cloneNode(true));
        highlightDIV.appendChild(name.cloneNode(true));
        highlightDIV.appendChild(brand.cloneNode(true))
        highlightDIV.appendChild(priceDiv.cloneNode(true));
        highlightDIV.appendChild(buildElement('p',clearTags(product.description),['prodDescription']));

        /// Determine metrics and phrasing

        if(product.parsedPrice !== null) {
            buildComparisonDiv(product.parsedPrice,selectionMetrics,'this selection',highlightDIV);
            if(product.product_type !== null) {
                buildComparisonDiv(product.parsedPrice,allProducts.filter(cv => cv.product_type === product.product_type).map(cv => cv.parsedPrice),`all ${filterFormatter(product.product_type)}s`,highlightDIV);
            }
            if (product.brand !== null) {
                buildComparisonDiv(product.parsedPrice,allProducts.filter(cv => cv.brand === product.brand).map(cv => cv.parsedPrice),`all products by ${filterFormatter(product.brand)}`,highlightDIV);
            }
        } else highlightDIV.appendChild(buildElement('p','Nothing to Compare',['comparisonHeader']));

        /// Build Clear button
        const clear = buildElement('button','Clear',[],'clear');
        ael('click',e => {
            e.preventDefault();
            highlightDIV.style.display = 'none';
        },clear)
        highlightDIV.appendChild(clear);

        highlightDIV.style.display = 'block';

    },compareButton)

    buttonsDiv.appendChild(compareButton);

    cell.appendChild(buttonsDiv);

    if (favoriteProducts[`${product.id}`] !== undefined) {
        updateFavorite(cell);
    }

    return cell;
}

function populateDropdown(dropdown,array) {
    for(let i = 0; i < array.length; ++i) {
        if ((array[i] !== 'null') && (array[i] !== '')) {
            const option = buildElement('option',array[i]);
            option.value = i;
            dropdown.appendChild(option);
        }
    }
}

/// REMOVE
function createArrayOfValuesStoredInKey(arr,key,alphabetize = true) {
    // The goal of this function is to take an array of objects and a key and then
    //     return an array of all unique values stored in that key within all the
    //     objects in the array
    const values = {};

        for(const pair in arr) {
            // Detect if value at arr[pair] is an array
            if(Array.isArray(arr[pair][key])) {
                // If so, then add each element of that array to `values` as a key
                for(const el of arr[pair][key]) {
                    values[el] = true;
                    }
                }
            else if (arr[pair][key]) {
                // If it's not an array, then just add it as is to `values` as a key
                values[arr[pair][key]] = true
            }
        }
    
        // Then, create an array that is just the keys of `values`
        //     (This way we have an array of all unique values stored in that key)

        if(alphabetize) {
            return ((Object.keys(values)).sort()).map(cv => {
            return {
                scored: cv.replace(' ','_'),
                spaced: cv.replace('_',' ')
            }
            
        });
    } else {
        return (Object.keys(values)).map(cv => {
        return {
            scored: cv.replace(' ','_'),
            spaced: cv.replace('_',' ')
        }});
    }
}

/// REMOVE
function filterByKeyValue(array,key,value) {
    const indexes = [];
    for(const index in array) {
        if (Array.isArray(array[index][key])) {
            for(const el of subArray) {
                if (el === value) ids[index] = true;
            }
        } else if (array[index][key] === value) ids[index] = true;
    }

    return indexes;
}

function capitalizeFirsts(string) {
    const returnString = [];
    let capsNext = true;
    for(let i = 0; i < string.length; ++i) {
        if (capsNext) {
            returnString.push(string[i].toUpperCase());
            capsNext = false;
        } else returnString.push(string[i]);
        if (string[i] === ' ') capsNext = true;
        };
    return returnString.join('');
}

function logOutUser() {
    user = null;
    logInDIV.style.display = 'block';
    userOptionsDIV.style.display = 'none';
    greeting.innerHTML = `No user currently signed in<br>Sign in below!`;
    for (const button of [...q('.favoriteButton',true)]) {
        button.classList.add('inactive');
    }
    for (const cell of [...q('.prodCell',true)]) {
        updateFavorite(cell,false);
    }
    favoriteProducts = {};
    sendTopBar('Logged out!');
}

function logInUser(username) {
    user = username;
    logInFRM.username.value = '';
    logInFRM.password.value = '';
    logInBTN.classList.add('inactive');
    registerBTN.classList.add('inactive');
    greeting.textContent = `Hello, ${user}!`
    logInDIV.style.display = 'none';
    userOptionsDIV.style.display = 'block';
    fetch(`http://localhost:3000/users/${encodeURI(user)}`)
    .then(res => res.json())
    .then(json => {
        if (json.favorites) {
            favoriteProducts = json.favorites;
            for (const cell of [...q('.prodCell',true)]) {
                // Both the class and the key are strings, so they eval to equal
                if (favoriteProducts[cell.classList[2]] !== undefined) {
                    updateFavorite(cell);
                }
            }
            for (const button of [...q('.favoriteButton',true)]) {
                button.classList.remove('inactive');
            }
        } else favoriteProducts = [];
    })
}

function sendTopBar(message,easeSec = 1,duration = 3,refresh = 50) {
    const topBar = buildElement('div',null,['topBarDiv']);
    topBar.style.display = 'block';
    topBar.style.top = '-76px';
    topBarDIV.appendChild(topBar);
    
    const p = buildElement('p',message,['topBarMessage']);
    topBar.appendChild(p);

    const easeIn = createGeometricSeq(76,easeSec,refresh);

    moveAlongArray(easeIn,topBar,'top',0,true);
    setTimeout(() => {
        moveAlongArray(easeIn,topBar,'top',0);
        setTimeout(() => topBar.remove(),(easeIn.length * refresh));

    },(easeIn.length * refresh) + (duration * 1000));

}

function createGeometricSeq(span,seconds,refresh = 50) {
    const steps = (seconds * 1000) / refresh;
    const returnArray = [];
    const multiplier = (span + 1) ** (1/steps);
    for(let i = 0; i <= steps; ++i) {
        returnArray.push((multiplier ** i) - 1)
    }
    return returnArray;
}

function moveAlongArray(array,element,property,subtractFrom = null,reverse = false) {
    element.style[property] = `${produceFinal(array,0,subtractFrom,reverse)}px`;
    let i = 1;
    const IV = setInterval(() => {
        if (i < array.length) {
            element.style[property] = `${produceFinal(array,i,subtractFrom,reverse)}px`;
            ++i;
        }

        if (i === array.length) clearInterval(IV);
    },50)
}


function produceFinal(array,i,subSubtractFrom,subReverse) {
    let final = subReverse ? array[array.length - i] : array[i];
    if (typeof subSubtractFrom === 'number') final = subSubtractFrom - final;
    return final;
}

function buildColorBox(colorObject,id) {
    const box = buildElement('div',null,['colorBox',`${id}`]);
    box.style.backgroundColor = `${colorObject.hex_value}`;

    ael('click',e => {
        // Clear Previous
        highlightDIV.textContent = '';

        // Build color details (Swatch, name, hex value)
        const color = buildElement('div',null,['color',`${id}`]);
        color.style.backgroundColor = colorObject.hex_value;
        highlightDIV.appendChild(color);

        const nameFormatted = colorObject.colour_name == null ? 'No Color Name' : colorObject.colour_name;
        const nameEl = buildElement('p',capitalizeFirsts(nameFormatted),['colorName',`${id}`]);
        highlightDIV.appendChild(nameEl);

        const hex = buildElement('p',colorObject.hex_value,['colorHex',`${id}`]);
        highlightDIV.appendChild(hex);

        // Show products with this color
        const showProducts = buildElement('button','Show Products with this Color',['showProductsByColor',colorObject.hex_value]);
        ael('click',e => {
            e.preventDefault();
            constrainedProducts = [];
            
            constrainedProducts = allProducts.filter(cv => {
                for(const color of cv.product_colors) {
                    if (color.hex_value === e.target.classList[1]) return true;
                }
                return false;
            });

            fillDisplay(constrainedProducts);

        },showProducts)
        highlightDIV.appendChild(showProducts);

        // Build Clear Button
        const clear = buildElement('button','Clear',['clear']);
        ael('click',e => {
            e.preventDefault();
            highlightDIV.style.display = 'none';
        },clear)
        highlightDIV.appendChild(clear);

        // Display
        highlightDIV.style.display = 'block';

    },box)

    return box;
}

function roundToPlace(number,place = 0.01) {
    const multiplier = place ** -1;
    return Math.round(number * multiplier) / multiplier;
}

function fillDisplay(array) {

    /// Create Array
    const prices = array.map(cv => cv.parsedPrice);
    
    /// Generate metrics with array
    selectionMetrics = findMetrics(prices,[roundToPlace]);

    /// Update DOM with metrics
    if(selectionMetrics.isMetricsObject) {
        selectionAvg.textContent = `$${formatPrice(selectionMetrics.avg)}`;
        selectionMin.textContent = `$${formatPrice(selectionMetrics.min.value)}`;
        minBTN.textContent = 'Show';
        selectionMax.textContent = `$${formatPrice(selectionMetrics.max.value)}`;
        maxBTN.textContent = 'Show';

    } else for(const metric of [selectionAvg,selectionMin,selectionMax]) {
        metric.textContent = 'No Prices Listed!';
        };
    
    /// CLEAR DISPLAY AREA
    displayDIV.innerHTML = '';

    /// FILL DISPLAY AREA
    for(let i = 0; i < array.length; ++i) {
        displayDIV.appendChild(buildCell(array[i],i));
    };
    
    /// SEND COMPLETION MESSAGE
    if (array.length !== 1) sendTopBar(`Found ${array.length} results!`); else sendTopBar(`Found ${array.length} result!`);
}

function formatPrice(float) {
    float = roundToPlace(float,0.01);
    if (float === Math.floor(float)) return float += '.00';
    else if (float * 10 === Math.floor(float * 10)) return float += '0';
    return float;
}

function clearTags(string) {
    if (string === null) return '';
    let returnString = string.replaceAll(/(<([^>]+)>)/ig,' ');
    return returnString.replaceAll('\n','');
}

function implementShowButton(button,element,closedText,openText) {
    ael('click',e => {
        e.preventDefault();
        element.style.display = element.style.display === '' ? 'block' : '';
        button.textContent = button.textContent === closedText ? openText : closedText;
    },button)
}

function getFilterObject(objects,key,formatter,alphabetize = false) {

    const valuesSet = new Set()
    for (const object of objects) {
        if (Array.isArray(object[key])) {
            for (const element of object[key]) {
                valuesSet.add(element);
            }
        } else if (typeof object[key] === 'string') valuesSet.add(object[key]);
    }

    // Spread into an array to be referenceable by index
    let valuesRaw = [...valuesSet];
    // Map the raw values to 
    if (alphabetize) valuesRaw = valuesRaw.sort();
    let valuesFormatted = valuesRaw.map(formatter);

    return {
        valuesRaw: valuesRaw,
        valuesFormatted: valuesFormatted
    };;
}

function filterFormatter(string) {
    string = string.replaceAll('_',' ');
    return capitalizeFirsts(string);
}

function average(array) {
    return array.reduce((ac,cv) => ac += cv) / array.length;
}

function findValueDeviation(value,average) {
    const returnObject = {};
    returnObject.unit = value - average;
    returnObject.percent = roundToPlace(returnObject.unit * 100 / average,0.01);
    return returnObject;
}

function buildComparisonDiv(price,pricesArrayOrMetricsObject,groupName,parentNode) {
    const div = buildElement('div',null,['comparisonDiv']);

    const header = buildElement('p',`Compared to ${groupName}`,['comparisonHeader']);
    div.appendChild(header);

    /// DETERMINE GROUP METRICS
    // If the pricesArrayOrMetricsObject is an array, then generate a metrics object
    // for it and assign that to groupMetrics, otherwise, assign groupMetrics
    // the value passed to pricesArrayOrMetricsObject so that the function can
    // use the metrics object we pass it
    const groupMetrics = Array.isArray(pricesArrayOrMetricsObject) ?
        findMetrics(pricesArrayOrMetricsObject,[roundToPlace]) :
        pricesArrayOrMetricsObject;

    /// CREATE AND FILL COMPARISON MESSAGE j2
    const comparisonMessage = buildElement('p',null,['comparisonMessage']);

    if ((groupMetrics.isMetricsObject) && (price !== null)) {
        const difference = findValueDeviation(price,groupMetrics.avg);
        if (difference.unit > 0) {
            comparisonMessage.textContent = `$${formatPrice(difference.unit)} (${difference.percent}%) higher than average`;
        } else if (difference.unit < 0) {
            comparisonMessage.textContent = `$${formatPrice(-1 * difference.unit)} (${-1 * difference.percent}%) lower than average`;
        } else if (difference.unit === 0) comparisonMessage.textContent = 'It is the average price';

        div.appendChild(comparisonMessage);
        

        // Most/least expensive product messages
        if (price === groupMetrics.max.value) div.appendChild(buildElement('p','This is the most expensive item',['priceWarning']));
        if (price === groupMetrics.min.value) div.appendChild(buildElement('p','This is the least expensive item',['priceWarning']));
    }

    parentNode.appendChild(div);
}

function findMetrics(array,formatters = []) {

    if (Math.max(array) === 0) return {isMetricsObject: false}; 

    const max = {
        value: Math.max(...array),
        ids: []
    }
    const min = {
        value: Math.min(...array.filter(cv => cv !== null)),
        ids: []
    }

    for(const index in array) {
        if (array[index] === max.value) max.ids.push(index);
        if (array[index] === min.value) min.ids.push(index);
    }

    let avg = average(array.filter(cv => cv !== null));

    for (const formatter of formatters) {
        avg = formatter(avg);
        max.value = formatter(max.value);
        min.value = formatter(min.value);
    }

    return {
        avg: avg,
        max: max,
        min: min,
        isMetricsObject: true
    }
    
}

function updateFavorite(cell,wasFavorited = true) {
    if (wasFavorited) {
        cell.style.backgroundColor = 'pink';
        cell.querySelector('.colorsDiv').style.backgroundColor = 'pink';
        cell.querySelector('.favoriteButton').textContent = 'Unfavorite';
    } else {
        cell.style.backgroundColor = '#323A48';
        cell.querySelector('.colorsDiv').style.backgroundColor = '#323A48';
        cell.querySelector('.favoriteButton').textContent = 'Favorite';
    }
}

function adjustGrid(element,width,divisionWidth) {
    s('grid resized');
    element.style.gridTemplateColumns = `repeat(${Math.max(1,Math.floor(width / divisionWidth))}, max-content)`;
}

// Random # of products feature

// Just have loading sign

// Upon clicking randomize, a dom element with some product info is created

// Super Filter function that's passed an array of filter function callbacks
// *For each* function in Super filter function, modify returnProducts
// Then generate first 10

/*  take a dropdown element
    add option for each item meant to be in dropdown
    need: array of all items ^^
    how get?

    api doesn't provide list of brands within api
    gonna have to iterate thru each product and store brand in an object
    then Object.keys(brands)
    then run that thru the dropdownpopulator


    Dropdown Populator:
    for each element of provided array, add <option>
    element into provided element
    set .value to provided value

    Translate currency
    -Should be taken care of before cell is built
    -No cell should list pounds
    Enact:
    -In buildCell
    -Before price formatting
    -Multiply unformatted price by a multiplier stored in an exchange rates object


    getFiltrations(array of objects(objs), array of keys to search thru(keys),beautifier,alphebetizeOption) {
        initialize returnObject
        for each key in object 1 of objs {
            (if that key is contained in the keys array)
            if (!!keys.find(cv => cv === key)) {
                initialize the keyDataObject = {
                    nameRaw: key,
                    nameRefined: key.beautifier(),
                    valuesRaw: [],
                    valuesRefined; []
                }
                initialize valuesSet = {}
                for each object in objs {
                    if (not an array) {
                    valuesSet.add(object.key)
                    }
                    if (is an array) {
                        for each element of array {
                            valuesSet.add(object.key[element])
                        }
                    }
                }
                keyDataObject.valuesRaw = Array.from(valuesSet)
                if (alphabetize) keyDataObject.valuesRaw.sort();
                keyDataObject.valuesRefined = keyDataObject.valuesRaw.map(beautifier);
                returnObject.key = keyDataObject;
            }
        }
        return keyDataObject;
    }


    for each key in keysToLookFor {
        for each key in arrayOfObjects[0] {
            if (key === key)
        }
    }
    ^Runs thru all keys in object for each key in keysToLookFor
    Runs thru 10 keys 3 times

    Vice Versa
    ^Runs thru all keys in keysToLookFor for each key in object
    runs thru 3 keys 10 times

*/